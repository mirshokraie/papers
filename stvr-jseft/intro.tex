\section{Introduction} \label{Sec:intro}
\javascript plays a prominent role in modern web applications. To test their \javascript applications,  developers often write test cases using web testing frameworks such as \selenium (GUI tests) and \qunit (\javascript unit tests). Although such frameworks help to automate test execution, the test cases still need to be written manually, which is tedious and time-consuming. 
%at the GUI level (e.g., Selenium) or \javascript function level (e.g., QUnit).
%ALi: (this is still the case with our test cases). Further, the test cases may break whenever there are changes to the application, which make them unstable.
 
Further, the event-driven nature of \javascript as well as its runtime interaction with the Document Object Model (DOM) make \javascript applications error-prone \cite{Ocariza:esem2013} and difficult to test. 
The highly dynamic behaviour of \javascript can result in prohibitively large test suites containing thousands of test cases. This hinders the test suite comprehension. Moreover, by growing the size of test suite, it can become expensive to execute on new versions of the application as such test suites often contain fragile, or redundant test cases \cite{harrold:tosem1993}. However, removing test cases may negatively affect the fault finding capability of the test suite.
%it challenging to effectively write stable test cases that achieve high coverage. %\karthik{Should we define stable ?} 
%Despite these challenges, little attention has been paid to automated test generation for \javascript applications.
%
%Several previous research projects have explored automated testing of \javascript applications. 
%For instance, Mesbah \etal \cite{mesbah:tse12} use dynamic analysis  to construct a model of the application's state space, from which test cases are created.
%Saxena \etal \cite{song:symb10} combine random test generation with the use of symbolic execution for systematically exploring the application's event space as well as its value space.
%Artzi \etal \cite{artzi:icse11} present a framework for automated feedback-directed test generation of \javascript towards inputs that yield increased coverage. 
%While these approaches support the automated generation of sequence of test cases, they do not address the oracle creation problem to check the correctness of the application's behaviour for the test sequences generated.
%
%
%While such tools help testers to design their test suite by providing an environment to record the event-enabled GUI actions, \javascript testing remains a challenging task as manually exploring different possible executions of the application is difficult. 
%The event driven and highly dynamic nature of the \javascript, as well as its complex interaction with Document Object Model (DOM) make it difficult for  test suites to achieve high coverage. 
%While tools such as Selenium test the correct functionality of the application after a particular event is triggered,

Researchers have recently developed automated test generation techniques for \javascript-based applications \cite{artzi:icse11, marchetto:search, tonella:icst08, mesbah:tse12, song:symb10}. However, current web test generation techniques suffer from two main  shortcomings, namely, they:

\begin{enumerate}%[noitemsep, nolistsep]
\item Target the generation of \emph{event sequences}, which operate at the event-level or DOM-level to cover the state space of the application. These techniques fail to capture faults that  do not propagate to an observable DOM state. As such, they potentially miss this portion of code-level \javascript faults. In order to capture such faults, effective test generation techniques need to target the code at the \javascript unit-level, in addition to the event-level.
\item Either ignore the oracle problem altogether or simplify it through generic \emph{soft oracles}, such as  W3C HTML  validation \cite{artzi:icse11,mesbah:tse12}, or  \javascript runtime exceptions \cite{artzi:icse11}.
A generated test case without assertions is not useful since coverage alone is not the goal of software testing. For such generated test cases, the tester still needs to  manually write many assertions, which is time and effort intensive. 
On the other hand, soft oracles  target generic fault types and are limited in their fault finding capabilities.   %\cite{Richardson:icse92}. 
%While there has been some work on the generation of test inputs \cite{song:symb10},  
%Despite such limitations, the automatic creation of strong test oracles, \ie assertions, has not gained much attention. 
However, to be practically useful, unit testing requires strong oracles  to determine whether the application under test executes correctly.
%While automated test generation helps in achieving higher code coverage,  
\end{enumerate}
%Unit testing at the \javascript code level, in which each function is individually examined against the correct output, is particularly helpful in locating the root cause of a \javascript error. This is especially true if the fault in the application does not propagate to the observable DOM state. 
To address these two shortcomings, we propose an automated test case  generation technique for \javascript applications. 

Our approach, called \tool (JavaScript Event and Function Testing) operates through a three step process. 
First, it dynamically explores the event-space of the application using a \emph{function coverage maximization} method, to infer a test model. Then, it generates test cases at two complementary levels, namely, DOM event and \javascript functions. Our technique employs a novel \emph{function state abstraction} algorithm to minimize the number of function-level states needed for test generation.
Finally,  it automatically generates test oracles, through a mutation-based algorithm. This paper is a substantially expanded and revised version of our paper from early 2015 \cite{mirshokraie:icst15}.

%
%, in which a modified version of the program called a mutant is
%generated by seeding a single fault into the program. A mutant is killed, if a test input can distinguish
%the mutant from the original application~\cite{demillo:computer1978}. 
%Mutation testing is typically used to evaluate the quality of a test suite~\cite{demillo:computer1978}, or to generate test cases that kill  mutants~\cite{fraser:tse12}. In our work, we adopt mutation testing to efficiently generate test oracles for \javascript applications. 
%\ali{remember to FILL in numbers}
%{\em 
%To the best of our knowledge, our  are the first to automatically generate unit tests at the function-level, coupled with test oracles, for  \javascript-based applications.
%} we can emphasis this after it is accepted. 

%{\em To out knowledge, we are the first to use mutation testing for oracle generation in JavaScript-based web applications.}
%A preliminary version of this work appeared in a short New Ideas paper \cite{shabnam:ase13}. In this current paper, we present the complete technique with conceptually significant improvements, including detailed new algorithms (Algorithms \ref{Alg:stateAbstractionAlgo}--\ref{Alg:oracleGenAlgo}), a fully-functional tool implementation, and a thorough empirical analysis on 13 \javascript applications, providing evidence of the efficacy of the approach.

This work makes the following main contributions:
\begin{itemize}

\item An automatic technique to generate test cases for \javascript functions and events.

%\item An algorithm for dynamic exploration guidance of the application to maximize \javascript function coverage;
\item A combination of function converge maximization and function state abstraction algorithms to efficiently generate unit test cases;
%\item A novel algorithm for abstracting function states to reduce the state space in unit test generation;%\ali{add the state abstraction as a contribution}
%\item Automatic generation of unit tests to examine the correct behaviour of the \javascript individual functions as well as DOM events.
\item A mutation-based algorithm to effectively generate test oracles, capable of detecting regression \javascript and DOM-level faults;%capable of detecting faults in the \javascript code and the DOM tree of the  application;
\item The implementation of our technique in a tool called \tool, which is publicly available \cite{jseft-dl};%,  which requires no browser modifications, and is hence portable;
\item An empirical evaluation to assess the efficacy of \tool using 13 \javascript applications.
 %(Ali: This is a little bit risky and might agitate the reviewers) and thus recall achieved by \tool is on average 600\% better than \artemis. 
\end{itemize} 

The results of our evaluation show that on average (1) the generated test suite by \tool achieves a 68\% \javascript code coverage, 
(2) compared to \artemis, a feedback-directed \javascript testing framework \cite{artzi:icse11}, \tool achieves 53\% better coverage, and (3) the test oracles generated by \tool are able to detect injected faults with 100\% precision and 72\% recall.

%(3)  compared to \artemis, an existing \javascript testing framework \cite{artzi:icse11}, \tool achieves 53\% better coverage; and unlike \artemis that detects generic faults such as runtime exceptions and HTML validation errors, \tool detects faults at the \javascript code and DOM levels. 




