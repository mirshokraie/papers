\section{Discussion} \label{Sec:discussion}

\subsection{Stubborn Mutants}
The aim of our mutation testing approach is to guide testers towards potentially error-prone parts of the code while easing the burden of handling equivalent mutants by reducing the number of such mutations. However, reducing the number of equivalent mutants might imply a decrease in the number of generated stubborn (or hard-to-kill) mutants, which are particularly useful for test adequacy assessment. Our initial results indicate that while the proposed guided approach reduces the number of equivalent mutants, it does not negatively affect the number of stubborn mutants generated. This finding is in line with a recent empirical study \cite{yao:icse14}, in which  no precise correlation was found between the number of equivalent mutants and stubborn mutants. However, we acknowledge that our finding is based on  preliminary results and more research in this direction is needed. 

In the following, we discuss different types of stubborn mutants we observed in our evaluation of \mutandis and how they can be utilized by a guided mutation generation technique to increase the number of hard-to-kill mutants.
 Based on our observations, stubbornness of mutants in \javascript applications stems from (1) the type and ultimate location of the mutation operator, and (2) specific characteristics of \javascript functions. We discuss each in the next two subsections, respectively.

\subsection{Type and Location of Operators} 

We notice that the type of the mutation operator as well as the ultimate location of the mutation affect the stubbornness of generated mutant. As far as the variable and branch mutations are concerned, the following mutations can result in stubborn mutants based on our observations:  %Such mutants remain undetected despite the moderate to high quality of the test suites.
\begin{itemize}
\item Variable mutations that happen in the body of conditional statements with more than one nested statement, where the conditions are involved with both variable as well as DOM related expressions. To satisfy such conditions, not only the variables should hold proper values, but also the proper structure as well as the properties of the involved DOM elements are required to be in place. This intertwined interaction limits the input space to only a few and challenging ones that are capable of satisfying the condition.  
\item Replacing the prefix unary operators with postfix unary operators, e.g., \code{++variable} to \code{variable++}.
\item Replacing the logical operators in conditional statements when the statement contains more than one different logical operator (e.g., \code{if(A \&\& B || C)\{...\}} to \code{if(A \&\& B \&\& C)\{...\}}).
\item Swapping \code{true/false} in conditional statements when the statement contains more than two conditions (e.g., \code{if(A \&\& B \&\& C)\{...\}} to \code{if(A \&\& !B \&\& C)\{...\}}).
\item Removing a parameter from a function call where the function contains more than three parameters.
\end{itemize}

As far as \javascript specific mutation operators are concerned, we observed that the following two mutations result in more stubborn mutants compared with the rest:

\begin{itemize}
\item Adding a redundant \code{var} keyword to a global defined variable.
\item Changing \code{setTimeout} calls such that the function is called without passing all the required parameters.
\end{itemize}
Our findings with respect to the type of mutation operator indicate that some classes of the operators tend to generate more stubborn mutants. While in our current approach we equally treat all classes, giving more priority to the hard-to-kill mutation operators would enhance the guided technique to potentially produce more stubborn mutants, which is part of our future work. 

\subsection{Characteristics of \javascript Functions} A given \javascript function can exhibit different behaviours at runtime. This is mainly due to two features of the \javascript language. 

%(1) common presence of \code{this} keyword used in the function \ali{this sentence is not clear, explain!}, and (2) function variadicity, which is common in web applications \cite{richards:pldi10}; i.e., functions can be invoked with an arbitrary number of arguments compared to the functions static signature.

First feature is related to the use of \code{this} in a function. The \code{this} keyword refers to the owner of the executed function in \javascript. Depending on where the function is called from at runtime, the value of \code{this} can be different. It can refer to (1) a DOM element for which the executed function is currently an event handler of, (2) the global \code{window} object, or (3) the object of which the function is a property/method of. Let's assume function \code{func} is defined as follows: \code{var func = function () \{console.log(this);\};}. If \code{func} is set as the event handler of a DOM element \code{elem} (e.g.; \code{elem.addEventListener(``click'', func, false);}), when \code{elem} is clicked, \code{this} will become the DOM element \code{elem}. However, if function \code{func} is directly invoked (e.g.; \code{func();}), \code{this} becomes the window object. Therefore, the value of \code{this} can dynamically change within the same function as the program executes. Considering the highly dynamic nature of \javascript applications, it is challenging for the tester to identify all such usage scenarios. Therefore, the mutation that occurs in these functions remains undetected unless the tester (1) correctly identifies all possible scopes from which the function can be invoked, and (2) associates each invocation with proper test oracles that are relevant to the value of \code{this}.     
%Using \code{this}, invoking the same function from each of the aforementioned entities provide the function with a different usage. 

Second feature is function variadicity, meaning that a \javascript function can be invoked with an arbitrary number of arguments compared to the function's static signature, which is common in web applications \cite{richards:pldi10}.
For example, if a function is called without passing all the expected parameters, the remaining parameters are set to \code{undefined}, and thus the function exhibits a different behaviour. Note that in cases where the programmer uses the same implementation of a given function for the purpose of different functionalities, the function achieves a high rank value according to our ranking mechanism since the function is executed several times from different scopes of the application. Testing the expected behaviour of all the possible functionalities is quite challenging, since invoking a particular functionality is often involved with triggering only a specific sequence of events capable of taking the application to the proper state. While the code coverage  of the function is the same among different usage scenarios, the mutated statement remains unkilled unless a proper combination of test input and oracle is used. We believe that if our guided approach takes into account such particular usages of a function,  which are barely exposed, it can reduce the number of equivalent mutants while increasing the number of hard-to-kill mutants, which forms part of our future work.
