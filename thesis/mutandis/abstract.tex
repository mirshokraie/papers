\section*{Abstract\footnote{This chapter appeared at the IEEE Transactions on Software Engineering (TSE), 2015 \cite{mirshokraie:tse15}.}}
%Mutation testing is an effective test adequacy assessment technique. 
%However, it suffers from two main issues.  First, there is a high computational cost in executing the test suite against a potentially large pool of generated mutants. Second, there is much effort  involved in filtering out equivalent mutants, which are syntactically different but semantically identical to the original program.
%Prior work has mainly focused on detecting equivalent mutants after the mutation generation phase, 
%which is computationally expensive and has limited efficiency.
%We propose an algorithm to select variables and branches for mutation as well as a metric, called $FunctionRank$, to rank functions according to their relative importance from the applications behaviour point of view.  We present a technique that leverages static and dynamic program analysis to guide the mutation generation process a-priori towards parts of the code that are more  likely to influence the program's output.  
%Further, we focus on the \javascript language, and propose a set of mutation operators that are specific to web applications. We implement our approach in a tool called \codename.  We empirically evaluate \codename on a number of web applications to assess the efficacy of the approach. Our results show that (1) more than 93\% of generated mutants are non-equivalent, (2) the mutations cause normal to major loss of functionality, (3) more than 70\% of the mutations causing major loss of functionality are in the top 20\% ranked functions, (4) surviving non-equivalent mutations are in the top 30\% of the functions ranked by our $FunctionRank$.
Mutation testing is an effective test adequacy assessment technique. However, there is a high computational cost in executing the test suite against a potentially large pool of generated mutants. Moreover, there is much effort involved in filtering out equivalent mutants. Prior work has mainly focused on detecting equivalent mutants after the mutation generation phase, which is computationally expensive and has limited efficiency. We propose an algorithm to select variables and branches for mutation as well as a metric, called $FunctionRank$, to rank functions according to their relative importance from the application's behaviour point of view. We present a technique that leverages static and dynamic analysis to guide the mutation generation process towards parts of the code that are more likely to influence the program's output. Further, we focus on the \javascript language, and propose a set of mutation operators that are specific to web applications. We implement our approach in a tool called \mutandis. The results of our empirical evaluation show that 
(1) more than 93\% of generated mutants are non-equivalent, 
%(2) the mutations cause normal to major loss of functionality, 
%(2) more than 70\% of the mutations causing normal to major loss of functionality are in the top 20\% ranked functions, 
and (2) more than 75\% of the surviving non-equivalent mutants
are in the top 30\% of the ranked functions.
