\chapter{Conclusions} \label{Chap:conc}
\javascript is increasingly being used to create modern interactive web applications that offload a considerable amount of their execution to the client-side. \javascript is a notoriously challenging language for web developers to use, maintain, analyze and test. %This thesis has focused on exploring strategies for testing \javascript-based web applications.
The work presented in this dissertation aims at improving the state-of-the-art in testing \javascript web applications by proposing a new set of techniques and tools.
\section{Contributions}
%The main contributions of the thesis can be summarized as follows:
The main contributions of the thesis are as follows: 
\begin{itemize}
\item A new automated technique for \javascript regression testing, which is based on dynamic analysis to infer invariant assertions; The obtained assertions are injected back into the \javascript code to uncover regression faults in subsequent revisions of the web application under test. 
\item The first \javascript mutation testing tool, which is capable of guiding the mutation generation towards behaviour-affecting mutants in error-prone portions of the code; The mutation testing method combines dynamic and static analysis to mutate branches that are within highly ranked functions and exhibit high structural complexity.
\item An automatic technique to generate test cases for \javascript functions and events; We use a mutation-based algorithm to effectively generate test oracles, capable of detecting regression \javascript and DOM-level faults. The technique uses a combination of function converge maximization and function state abstraction algorithms to efficiently generate unit test cases.
\item Exploiting an existing DOM-based test suite to generate unit-level assertions for applications that highly interact with the DOM through the underlying \javascript code; We utilize
existing DOM-dependent assertions as well as useful execution information inferred from a DOM-based test suite to automatically generate assertions used for testing individual \javascript functions.
\end{itemize}
\section{Revisiting Research Questions} 
In the beginning of this thesis, we designed two research questions. We believe that the contributions show that we have addressed the research questions.
\headbf{Research Question 1}

\emph{How can we generate effective test cases for \javascript web applications?}

In order to answer the first research question, \chapref{jsart} targets web application testing from the invariant assertions points of view. These invariants formulate the main characteristics of the application under test that will remain unchanged as the application evolves. Therefore, these type of assertions can be used towards regression testing. The empirical study on nine open source \javascript applications show that the proposed approach is able to effectively infer stable assertions and 
detect regression faults with minimal performance overhead.

Our invariant generation technique is based on the assumption that the program specifications are not changed frequently in subsequent revisions. However, if major changes affect the core properties of the application, the inferred invariants from the original version may not be valid any longer. Moreover, unlike post-condition assertions, invariant-based ones are inline assertions, which are checked at different points of the program's code. Therefore, it can become difficult for the tester to comprehend these type of assertions.

In order to generate oracles that can be used during the common testing cycles of a large system, including unit and GUI testing, we proposed \jseft in \chapref{jseft}. \jseft generates test cases combined with post-condition assertions at the two complementary levels of unit and event-based tests. To evaluate the effectiveness of our approach we further consider a state-of-the-art \javascript test generation framework as a basis to compare our technique. The results of the empirical evaluation indicate that the approach generates test cases with high fault finding capability. One of the important observations from the results is that event-based tests can potentially miss the code-related errors (32\% on average) if the fault does not propagate to the observable DOM. We observed that the rate of missed faults are higher for the applications that have tight interaction with the DOM through the underlying \javascript code. This observation forms the basis of \chapref{atrina}, where we make use of the existing DOM-dependent assertions to generate code related unit-level assertions.

In \chapref{atrina}   

\emph{How can we effectively assess the quality of the written test suites for \javascript applications?}

\section{Future Work}
As web browsers become more powerful, building large-scale web applications using \javascript is increasingly becoming popular. This dissertation indeed needs to be incrementally revised to address the new emerging challenges from the continuously growing size of the deployed \javascript as well as the use of various \javascript utility plugins. 

Writing a testable code is crucial in the new web app era. However, using hidden scopes (\ie function closures) is quite popular in writing \javascript-based web applications. 
Hidden scopes in \javascript language provide a way to make variables and functions private, thus keeping them out of the global scope.
This is particularly important in the browser since all scripts share the same scope. Therefore it is quite easy to inadvertently select a variable or function name which is used by another library.
While function closures can be called at the highest program scope they belong to, it is not possible
to call them directly in test cases, which makes it challenging to assess their outcomes. 
If there are several self-contained hidden modules in the application, when a test fails while testing functions in the public API, it may be difficult for the tester to detect the cause of the failure.
To generate effective test cases we need to identify such hidden scopes, and if possible expose them to our testing unit through automated code refactoring. Therefore, one possible future direction is to measure the unit testability extent of the real-world \javascript web applications by conducting a thorough empirical study. The results of the study will help to identify the extent of either untestable or hard to test code written by developers as well as the correlation between the location of the error in the code and the difficulty of pin pointing the root cause and resolving the error. \javascript developers can make use of the results of empirical study as a coding recommendation to make their future applications more testable and consequently more maintainable. 

In this thesis we considered DOM-level mutations as a means of generating DOM-level assertions. However, this can be improved in many different ways. n traditional mutation testing, the output is defined over the returned values of functions, however in DOM-level mutation, the output is the resulting DOM state from an executed event. As the scope of the mutation operators differs from the traditional code-based mutant generators, we need to define new DOM-based operators that can be applied on DOM elements. We further need to design a new equivalent mutant detection technique. In code-based mutation, the output of an individual unit is analyzed to observe differences between the original and the mutated version, and therefore detect a potential equivalent mutant. However, at the DOM-level mutation, DOM elements can be accessed through the entire application execution, thus making the mutation analysis more challenging.

In this dissertation, we mostly relied on dynamic analysis of the \javascript to infer the application's behaviour. However, because of the huge event space of such applications, dynamic analysis techniques may not be able to explore the full scale functionality of the application in a limited amount of time. Therefore, another possible future direction is to investigate hybrid approaches that take dynamic as well as static analysis of the code into account without facing the negative side effects of each techniques. The more complete model of the application's behaviour through a hybrid analysis will enable our current testing technique to detect more errors in the application.  



