\section{Related Work} \label{Sec:related}
While automated test generation has significantly addressed in the literature, there has been limited work on supporting the construction of test oracles. Recently, Harman \etal \cite{harman:tech13} have conducted a comprehensive survey of current techniques used to address the oracle problem.
Mesbah \etal \cite{mesbah:tse12} automatically produce generic invariants in a form of soft oracles to test AJAX applications. JSART \cite{mirshokraie:icwe12} automatically infers \javascript invariants from the execution traces for the purpose of regression testing. Jalangi \cite{sen:fse13} is a framework to support writing of heavy-weight dynamic analyses. The framework detects generic \javascript faults such as null, undefined values, and type inconsistencies. Jensen \etal \cite{jensen:fse13} incorporate server interface descriptions to test the correctness of communication patterns between client and server through learning the communication patterns from sample data in AJAX applications.
Xie \etal explore test oracle generation for GUI systems \cite{xie:tosem07}. 
Eclat \cite{pacheco:ecoop05}, and DiffGen \cite{taneja:ase08} are used for automatically generating invariant-based oracles. 
Our work is different from these approaches in that we use the available DOM-related information in a human written test suite to infer unit-level assertions at the \javascript code-level. Moreover, we generate assertions that capture application's behaviour, rather than generic and soft oracles. 

Fraser \etal \cite{fraser:tse12} propose a mutation-based oracle generation system called $\mu$TE\-ST. $\mu$TE\-ST automatically generates unit tests for Java object-oriented classes by employing a genetic algorithm which target mutations with high impact on the application's behaviour. They further enhance the system \cite{fraser:issta11} to improve human comprehension through identifying relevant pre-conditions on the test inputs and post-conditions on the outputs. The authors assume that the tester will manually correct the generated oracles. However, the results on the effectiveness of such approaches which rely on the "generate-and-fix" assumption to construct test oracles are not conclusive \cite{fraser:issta13}

Staats \etal \cite{staats:icse12} propose an oracle data selection technique, which is based on mutation testing to produce oracles and rank the inferred oracles in terms of their fault finding capability. This work suffers from the scalability issues of mutant-generation based techniques as well as the problem of estimating the proper number of mutants required for generating effective oracle data set.
Similar to mutation-based techniques, differential test case generation approaches \cite{taneja:ase08, elbaum:tse09} also target generating test cases that show the difference between two versions of a program. %However, mutation-based techniques do not require two different versions of the application since the generated differences are in the form of controllable mutations to detect regression faults in future versions of the program.
Pastore \etal \cite{pastore:icst13} exploit crowd sourcing approach to check assertions. In this approach the developer produces tests and provides sufficient API documentation for the crowd such that crowd workers can determine the correctness of assertions. However, recruiting qualified crowd to generate test oracles can be quite challenging.

In the context of leveraging the existing test cases to generate more complex tests, Pezz\`e \etal \cite{pezze:icst13} propose a technique to construct integration tests which focus on class interactions by utilizing the unit test cases. 
The integration tests are formed by combining initialization and execution sequences of simple unit tests to form new ones. However, the proposed technique does not deal with assertions.
eToc \cite{tonella:issta04} and EvoSuite \cite{fraser:icst12} use search based techniques to evolve the initial population of test cases. Their main goal is to increase the code coverage achieved by the test suite. However, in this work our aim is to increase the fault finding capability by focusing on test assertions rather than increasing the code coverage.
Milani Fard \etal \cite{milanifard:ase14} propose Testilizer which utilizes DOM-based test suite of the web application to explore alternative paths and consequently regenerate assertions for new detected states. Our work is different from this approach in that we exploit DOM-related information in a human written test suite to capture the behaviour of the application at the unit-level \javascript. Furthermore, they do not generate code-based assertions which we do.
  


