\section{Introduction} \label{Sec:intro}
To test \javascript applications, developers often write test cases using web testing frameworks such as \selenium (GUI tests) and \qunit (\javascript unit tests). Although such frameworks help to automate test execution, the test cases still need to be written manually, which is time-consuming. 
%at the GUI level (e.g., Selenium) or \javascript function level (e.g., QUnit).
%ALi: (this is still the case with our test cases). Further, the test cases may break whenever there are changes to the application, which make them unstable.
%it challenging to effectively write stable test cases that achieve high coverage. %\karthik{Should we define stable ?} 
%Despite these challenges, little attention has been paid to automated test generation for \javascript applications.
%
%Several previous research projects have explored automated testing of \javascript applications. 
%For instance, Mesbah \etal \cite{mesbah:tse12} use dynamic analysis  to construct a model of the application's state space, from which test cases are created.
%Saxena \etal \cite{song:symb10} combine random test generation with the use of symbolic execution for systematically exploring the application's event space as well as its value space.
%Artzi \etal \cite{artzi:icse11} present a framework for automated feedback-directed test generation of \javascript towards inputs that yield increased coverage. 
%While these approaches support the automated generation of sequence of test cases, they do not address the oracle creation problem to check the correctness of the application's behaviour for the test sequences generated.
%
%
%While such tools help testers to design their test suite by providing an environment to record the event-enabled GUI actions, \javascript testing remains a challenging task as manually exploring different possible executions of the application is difficult. 
%The event driven and highly dynamic nature of the \javascript, as well as its complex interaction with Document Object Model (DOM) make it difficult for  test suites to achieve high coverage. 
%While tools such as Selenium test the correct functionality of the application after a particular event is triggered,

Researchers have recently developed automated test generation techniques for \javascript-based applications \cite{artzi:icse11, marchetto:search, tonella:icst08, mesbah:tse12, song:symb10}. However, current web test generation techniques suffer from two main shortcomings:

\begin{enumerate}[noitemsep, nolistsep]
\item Target the generation of \emph{event sequences}, that can potentially miss the portion of code-level \javascript faults.
\item Either ignore the oracle problem altogether or simplify it through generic \emph{soft oracles}.
%While automated test generation helps in achieving higher code coverage,  
\end{enumerate}
%Unit testing at the \javascript code level, in which each function is individually examined against the correct output, is particularly helpful in locating the root cause of a \javascript error. This is especially true if the fault in the application does not propagate to the observable DOM state. 
To address these two shortcomings, we propose an automated test case  generation technique for \javascript applications. 

Our approach, called \jseft (JavaScript Event and Function Testing) operates through a three step process. 
First, it dynamically explores the event-space of the application using a \emph{function coverage maximization} method, to infer a test model. Then, it generates test cases at two complementary levels, namely, DOM event and \javascript functions. Our technique employs a novel \emph{function state abstraction} algorithm to minimize the number of function-level states needed for test generation.
Finally,  it automatically generates test oracles, through a mutation-based algorithm.
%
%, in which a modified version of the program called a mutant is
%generated by seeding a single fault into the program. A mutant is killed, if a test input can distinguish
%the mutant from the original application~\cite{demillo:computer1978}. 
%Mutation testing is typically used to evaluate the quality of a test suite~\cite{demillo:computer1978}, or to generate test cases that kill  mutants~\cite{fraser:tse12}. In our work, we adopt mutation testing to efficiently generate test oracles for \javascript applications. 
%\ali{remember to FILL in numbers}
%{\em 
%To the best of our knowledge, our  are the first to automatically generate unit tests at the function-level, coupled with test oracles, for  \javascript-based applications.
%} we can emphasis this after it is accepted. 
%{\em To out knowledge, we are the first to use mutation testing for oracle generation in JavaScript-based web applications.}

This work makes the following main contributions:
\begin{itemize}

\item An automatic technique to generate test cases for \javascript functions and events.

%\item An algorithm for dynamic exploration guidance of the application to maximize \javascript function coverage;
\item A combination of function converge maximization and function state abstraction algorithms to efficiently generate unit test cases;
%\item A novel algorithm for abstracting function states to reduce the state space in unit test generation;%\ali{add the state abstraction as a contribution}
%\item Automatic generation of unit tests to examine the correct behaviour of the \javascript individual functions as well as DOM events.
\item A mutation-based algorithm to effectively generate test oracles, capable of detecting regression \javascript and DOM-level faults;%capable of detecting faults in the \javascript code and the DOM tree of the  application;
\item The implementation of our technique in a tool called \jseft, which is publicly available \cite{jseft-dl};%,  which requires no browser modifications, and is hence portable;
\item An empirical evaluation to assess the efficacy of \jseft using 13 \javascript applications.
 %(Ali: This is a little bit risky and might agitate the reviewers) and thus recall achieved by \tool is on average 600\% better than \artemis. 
\end{itemize} 

The results of our evaluation show that on average (1) the generated test suite by \jseft achieves a 68\% \javascript code coverage, 
(2) compared to \artemis, a feedback-directed \javascript testing framework \cite{artzi:icse11}, \jseft achieves 53\% better coverage, and (3) the test oracles generated by \jseft are able to detect injected faults with 100\% precision and 70\% recall.

%(3)  compared to \artemis, an existing \javascript testing framework \cite{artzi:icse11}, \tool achieves 53\% better coverage; and unlike \artemis that detects generic faults such as runtime exceptions and HTML validation errors, \tool detects faults at the \javascript code and DOM levels. 




