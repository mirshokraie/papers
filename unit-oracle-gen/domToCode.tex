\subsection{Relating DOM changes to the \javascript Code} \label{Sec:domToCode}
To determine the initial point of contact between DOM and the underlying \javascript code, we first cross reference the relevant DOM element with a set of DOM mutations obtained from the execution trace. Our execution trace contains information about the invoked functions, triggered events, as well as DOM mutations caused by the events as the test case runs. This way we can identify relevant events and functions corresponding to a DOM mutation. To figure out where the mutation originated in our execution trace we keep record of DOM accesses within the application. For each DOM access we track \javascript lines of code, that are responsible for updating the corresponding DOM element. After inferring DOM mutant statements within the code, we perform backward slice on the retrieved statements to gather the entire set of \javascript statements responsible for mutating a given DOM element. 
In order to capture dependencies exercised at run-time we use dynamic slicing. We first intercept and statically instrument those statements that may affect a given DOM element. The instrumented code keeps track of all updates and accesses to all relevant data and control dependencies. This trace is later used to extract a dynamic backwards slice.    
Once the test case runs, we collect traces from the instrumented code. This trace is used for extracting dynamically backward sliced statements.

The slicing technique starts by extracting instances of the initial slicing criteria from the trace. For each \textit{read} operations, the trace is traversed backwards to find the nearest related \textit{write} operation. Once found, the \textit{write} operation is added to the slice under construction. This process is repeated for all the data dependencies related to that write operation. A similar approach is taken for including control dependencies in the slice.
To address aliasing when computing the slice of a variable that has been set by a non-primitive value, we need to consider possible aliases that may refer to the same object. Specifically in \javascript \textit{dot notation} and \textit{bracket notation} is frequently used to modify objects at run time. While static analysis techniques often ignore addressing this issue \cite{Feldthaus:icse13}, we incorporate dynamic analysis in our slicing method. If a reference to an object of interest is saved to a second object's property, e.g. through the use of the \textit{dot notation}, the object of interest may also be altered via aliases of the second object. For example, after executing statement \code{a.b.c = objOfInterest;}, updates to \code{objOfInterest} may be possible through \code{a}, \code{a.b}, or \code{a.b.c}. To deal with such scenarios, our slicing technique searches through the collected trace and adds the forward slice for each detected alias to the current slice for our variable of interest (e.g. \code{objOfInterest}). 

By the end of backward slicing step we collect all the relevant statements to a given DOM element, which re later used to derive test assertions.    