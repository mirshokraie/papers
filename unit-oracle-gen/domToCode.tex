\subsection{Relating DOM changes to the \javascript Code} \label{Sec:domToCode}
To determine the initial point of contact between DOM and the underlying \javascript code, we first cross reference the DOM element as well as the property we are interested in with a set of DOM mutations obtained from the execution trace. Recall that our execution trace contains information about triggered events, event handlers, and DOM mutations caused by the events. Therefore, we can identify relevant events and invoked functions corresponding to a given DOM mutation. To figure out where the mutation originated in our execution trace we keep record of DOM accesses within the invoked functions. For each DOM access we track \javascript lines of code, that are responsible for updating the corresponding DOM element. After inferring DOM mutant statements within the code, we perform backward slice on the retrieved statements to gather the entire set of \javascript statements responsible for mutating a given DOM element. 
In order to capture code-level dependencies exercised at run-time we use dynamic slicing. 
Note that instrumenting the entire application's code to perform dynamic slicing incurs high performance overheads. To avoid this, we first intercept the code sent from the server to the client and then statically instrument only those statements that may affect a given DOM element.
To extract the subset of the code statements, we first find the \javascript closure scope which contains the definition of the variable in the initial slicing criteria. Then all references to the variable within the closure scope is found. Therefore, we can identify all locations in the code where the variable is updated, read, or a new alias is created. For each variable update/read related to the variable of the slicing criteria, we track the data dependencies for such an operation. The aforementioned steps are performed iteratively for each dependencies to collect the subset of code statements, which are instrumented for a given initial slicing criteria.
The instrumented code keeps track of all updates and accesses to all relevant data and control dependencies.   
Once the test case runs, we collect traces from the instrumented code. This trace is used to dynamically extract backwards slicing as well as forwards slicing statements. Note that in addition to backwards slicing which is later which is later used to generate explicit assertions, we also utilize forwards slicing to generate our implicit assertions (\secref{implicitAssertions}).  

The backwards slicing technique starts by extracting instances of the initial slicing criteria from the trace. For each \textit{read} operations, the trace is traversed backwards to find the nearest related \textit{write} operation. Once found, the \textit{write} operation is added to the slice under construction. This process is repeated for all the data dependencies related to that write operation. A similar approach is taken for including control dependencies in the slice.
Our slicing technique supports inter procedural slicing. For example, if a variable is assigned by the return value of a called function, the slicer recursively tracks the function and performs a backward slice on the statement returned by the called function. 

To address aliasing when computing the slice of a variable that has been set by a non-primitive value, we need to consider possible aliases that may refer to the same object. Specifically in \javascript \textit{dot notation} and \textit{bracket notation} is frequently used to modify objects at run time. While static analysis techniques often ignore addressing this issue \cite{Feldthaus:icse13}, we incorporate dynamic analysis in our slicing method. If a reference to an object of interest is saved to a second object's property, e.g. through the use of the \textit{dot notation}, the object of interest may also be altered via aliases of the second object. For example, after executing statement \code{a.b.c = objOfInterest;}, updates to \code{objOfInterest} may be possible through \code{a}, \code{a.b}, or \code{a.b.c}. To deal with such scenarios, our slicing technique searches through the collected trace and adds the forward slice for each detected alias to the current slice for our variable of interest (e.g. \code{objOfInterest}). 

By the end of backward slicing step we collect all the relevant statements to a given DOM element, which are later used to derive test assertions.    