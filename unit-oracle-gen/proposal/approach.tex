A large body of research on automated testing of \javascript web applications has focused on
automatically generating test input data to fulfill the coverage criteria, however, test oracles are
needed to detect failures. Manual oracle generation can be difficult, since it is challenging for the
tester to exactly analyze the expected behaviour of the application and figure out where to look
for the failures. There are two main issues involved with testing of \javascript applications.
\begin{itemize}
\item Current web test generation techniques target DOM-based test cases,
which operate at event level. Our previous findings (Pythia) indicate that DOM level tests can potentially miss the related portion of
code-level faults, while a more fine grained unit-level test and assertions are capable of detecting such faults.
\item Writing DOM based test cases using frameworks such as Selenium
requires little knowledge about the underlying client side code, however generating code-level tests is
challenging as the tester needs to fully understand the interaction between the observable DOM
and the \javascript code responsible for updating those DOM elements.
\end{itemize}
In this work we focus on generating test oracles for the \javascript code at unit level by making
use of manually written DOM based test cases. Note that we target web applications that have
rich interaction with the DOM through their \javascript code. In this research we propose a
backward slicing-based mechanism to specify test oracles for \javascript function-level
tests. In order to select potentially useful oracle candidates, we 
\begin{enumerate}
\item Identify all DOM elements
that are either accessed or checked in the manually written DOM-based test suite; 
\item Calculate the DOM usage frequency which is the frequency of the number of times that a DOM element has been accessed:
$DOMUsgFrq(elem)=\frac{NoOfElemAccss(elem)}{TotalElemsAccss}$, where $DOMUsgFrq(elem)$ is the usage frequency of DOM element $elem$, $NoOfelemAccss$ is the number of times that DOM element $elem$ is accessed, and $TotalElemsAccss$ is the total number of DOM accesses;
\item Select accessed DOM elements that their usage frequency is greater than or equal to $\frac{1}{NoOfDOMElems}$, where $NoOfDOMElems$ is the total number of DOM elements. Our final set of DOM elements $ElemsToTrack$ is computed as:
$ElemsToTrack=SelcAccssElems\cup AssertedElems$, where $SelcAccssElems$ is set of selected DOM elements according to their usage frequency, and $AssertedElems$ are DOM elements that are asserted in the test suite;    
\item Track DOM mutations of the selected elements in the previous step ($ElemsToTrack$). We subsequently find relevant portions of the code, which are responsible for the such DOM mutations by utilizing backward slicing technique; 
\item Extract accessible variables/objects $BWVars$ per function from the obtained relevant code;
\item Perform forward slicing on the previously extracted variables ($BWVars$) to find statements, that are influenced by these variables. This allows us to further predict parts of the code that will be affected by a modification to such variables. The final set of obtained variables per function is: $CandidateVars=BWVars\cup FWVars$, where $FWVars$ is the list of variables obtained by forward slicing.  
\item Rank $CandidateVars$ according to the following formula:

$rank(v\in CandidateVars)=\frac{\# UsedForMutAcc(v)}{\# MutAcc} + \frac{\# UsedForMutChked(v)}{\# MutChked}$

Where $rank(v)$ is the ranking value of variable $v$, $\# UsedForMutAcc(v)$ is the total number of
times that variable $v$ appears in the extracted portions of the code, $\# MutAcc$ is the total number of times that the
accessed DOM elements change during the test suite run. $\# UsedForMutChked(v)$ is the total
number of times that variable $v$ appears in the extracted code for mutations happen to the checked
DOM elements in the test suite, and $\# MutChked$ is the total number of times that checked DOM
elements are mutated. The ranking value of each variable indicates the relative importance of
that variable in mutating the accessed as well as checked DOM elements. We sort variables
associated with each function according to their rank value and select the first $n$ variables as the
oracle candidates for that function.
\end{enumerate}
\input{example}
%\figref{example}

To assess the efficacy of our oracle generation approach, we conduct an empirical study, in
which we address the following research questions:
RQ1: How effective is our approach in generating test oracles that detect faults?
RQ2: How does our approach compare to the existing mutation-based approach for identifying
oracle data sets?
RQ3: Is our approach more effective than DOM-based assertions written manually by the tester
in terms of fault finding capability?