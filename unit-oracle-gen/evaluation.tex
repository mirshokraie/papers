\section{Empirical Evaluation} \label{Sec:evaluation}
To quantitatively assess the efficacy of our test generation approach, we have conducted a case study, in which we address the following research questions:

\begin{description}[noitemsep]
\item [RQ1] How accurate is \tool in mapping DOM-based assertions to the corresponding \javascript code?
\item [RQ2] How effective is \tool in generating unit test assertions that detect faults?
\item [RQ3] Is our approach more effective than DOM-based assertions written manually by the tester in terms of fault finding capability? 
\item [RQ4] How does our approach compare to the existing mutation-based technique for identifying unit test assertions?
\end{description}

\tool and the experimental data are available for download \cite{atrina-dl}.
\subsection{Objects}
Our study includes four open source \javascript web applications that have \selenium test cases.
%Finding applications with executable Selenium test cases for \javascript applications is a big challenge.
\tabref{objectsTable} presents the experimental objects and their properties. Phormer \cite{phormer} is a photo gallery web application. EnterpriseStore \cite{enterpriseStore} is an asset management web application. WolfCMS \cite{wolfcms} is a content management system, and Claroline \cite{claroline} is a collaborative online learning and course management system. 
\input{objectsTable}
\subsection{Setup} \label{Sec:setup}
To address our research questions, we provide the URL as well as the available manually written DOM-based test suite of each experimental object to \tool. Unit level test assertions are then automatically generated by the tool.
\headbf{Accuracy (RQ1)} To evaluate the accuracy of \tool, we measure precision and recall. We manually compare the slices generated by \tool with the \javascript code that is relevant to each assertion. Precision and recall are defined as follows:
\begin{description}[noitemsep, nolistsep, font=\normalfont\itshape]
\item [Precision] is the fraction of lines in a slice produced by \tool, that are actually related to the human-written DOM-based assertion: $\frac{TP}{TP+FP}$ 
\item [Recall] is the fraction of the correct set of related lines of code to each assertion, which is actually present in the slice produced by \tool: $\frac{TP}{TP+FN}$ 
\end{description}
where $TP$ (true positives), $FP$ (false positives), and $FN$ (false negatives) respectively represent the number of lines of code that are correctly reported, falsely reported, and missed to report as related to the DOM-based assertion.
\headbf{Effectiveness (RQ2)} To assess the effectiveness of \tool, we measure the fault finding capability of the assertions generated by the tool. Moreover, to understand the effect of each type of assertion produced by \tool in detecting faults, we compare the fault detection rate of using (1) exclusively explicit assertions, (2) explicit assertions and implicit assertions, and (3) explicit assertions and candidate assertions. Since explicit assertions compose the core body of our assertions, we consider implicit and candidate assertions in conjunction with explicit ones.
       
The experimental objects do not come with a rich version history to apply \tool on real regression changes. Therefore we mimic regression faults by automatically injecting mutations to the application, and evaluate the tool's ability in detecting the seeded faults. We randomly inject 50 first-order mutations into the \javascript code of the applications. The mutation operators are chosen from a list of common operators such as changing the value of a variable, modifying a conditional statement, altering unary operations, as well as common mistakes made by developers when developing a given web application \cite{mirshokraie:tse15}, e.g., changing the ID/tag name passed into DOM access functions such as \code{getElementById} or \code{getElementsByTagName}, and modifying the attribute name/value in \code{setAttribute}. The fault is considered detected if an assertion generated by \tool fails when run on the mutated code, and our manual examination confirms that the failed assertion is detecting the seeded fault.
\headbf{Comparison with human-written DOM-based Assertions (RQ3)} To assess the usefulness of \tool, we compare the human written DOM-based assertions with the unit-level test assertions generated by our approach in terms of fault finding capability.
Similar to RQ2, we perform fault injection on both.
The faults injected into our experimental objects in response to RQ3 are the same as the ones that we seed in applications to answer RQ2.
\headbf{Comparison with Mutation-based Assertion Generation (RQ4)} To assess how \tool performs with respect to the current state-of-the-art oracle generation technique, we compare our tool's fault finding capability with the mutation-based assertion generation approach \cite{mirshokraie:icst15, fraser:tse12}. To generate mutation-based assertions for the \javascript code, we use human-written DOM-based test suite as a means to execute the application and infer the execution traces required for the purpose of mutation analysis. We perform the following steps to generate test assertions using mutation analysis.
\begin{enumerate}[noitemsep, nolistsep]
\item Remove assertions from the human-written DOM-based test suite.
\item Execute the test suite on the original version of the application to obtain execution traces.
\item Inject mutations for the purpose of oracle generation.
\item Execute the human-written test suite on the generated mutants, and produce test oracles by comparing execution traces obtained from the mutants and the original version of the application.
\end{enumerate}
The number of mutants, that are generated to produce test assertions is 50 for each application. Note that the implementation and evaluation of the mutation analysis technique both use mutation operators suggested by \cite{mirshokraie:tse15}. Therefore, our evaluation is biased in favour of mutation-based assertion generation approach over our technique.
\input{results}
\input{discussion}
\input{threatsToValidity} 

